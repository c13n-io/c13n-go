// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package services

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeInfoServiceClient is the client API for NodeInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeInfoServiceClient interface {
	//*
	//Returns version information about the current daemon.
	GetVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*Version, error)
	//*
	//Returns info about the current underlying node.
	GetSelfInfo(ctx context.Context, in *SelfInfoRequest, opts ...grpc.CallOption) (*SelfInfoResponse, error)
	//*
	//Returns the balance of the current underlying node.
	GetSelfBalance(ctx context.Context, in *SelfBalanceRequest, opts ...grpc.CallOption) (*SelfBalanceResponse, error)
	//*
	//Lists all nodes on the Lightning network.
	//
	//Returns a list of all nodes visible to the underlying Lightning node,
	//including the address of the current node.
	//Nodes with private channels are not visible if not directly connected to
	//the underlying node.
	GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	//*
	//Searches for a Lighting node based on their Lightning address.
	//
	//Returns a list of all nodes with that address, which will be at most 1.
	//The node must be visible from the underlying node.
	SearchNodeByAddress(ctx context.Context, in *SearchNodeByAddressRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	//*
	//Searches for a Lightning node based on their Lightning alias.
	//
	//Returns a list of all nodes with that alias visible from the underlying node.
	SearchNodeByAlias(ctx context.Context, in *SearchNodeByAliasRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	//*
	//Connects a node as a peer.
	ConnectNode(ctx context.Context, in *ConnectNodeRequest, opts ...grpc.CallOption) (*ConnectNodeResponse, error)
}

type nodeInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeInfoServiceClient(cc grpc.ClientConnInterface) NodeInfoServiceClient {
	return &nodeInfoServiceClient{cc}
}

func (c *nodeInfoServiceClient) GetVersion(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) GetSelfInfo(ctx context.Context, in *SelfInfoRequest, opts ...grpc.CallOption) (*SelfInfoResponse, error) {
	out := new(SelfInfoResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/GetSelfInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) GetSelfBalance(ctx context.Context, in *SelfBalanceRequest, opts ...grpc.CallOption) (*SelfBalanceResponse, error) {
	out := new(SelfBalanceResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/GetSelfBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/GetNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) SearchNodeByAddress(ctx context.Context, in *SearchNodeByAddressRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/SearchNodeByAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) SearchNodeByAlias(ctx context.Context, in *SearchNodeByAliasRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/SearchNodeByAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoServiceClient) ConnectNode(ctx context.Context, in *ConnectNodeRequest, opts ...grpc.CallOption) (*ConnectNodeResponse, error) {
	out := new(ConnectNodeResponse)
	err := c.cc.Invoke(ctx, "/services.NodeInfoService/ConnectNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeInfoServiceServer is the server API for NodeInfoService service.
// All implementations must embed UnimplementedNodeInfoServiceServer
// for forward compatibility
type NodeInfoServiceServer interface {
	//*
	//Returns version information about the current daemon.
	GetVersion(context.Context, *VersionRequest) (*Version, error)
	//*
	//Returns info about the current underlying node.
	GetSelfInfo(context.Context, *SelfInfoRequest) (*SelfInfoResponse, error)
	//*
	//Returns the balance of the current underlying node.
	GetSelfBalance(context.Context, *SelfBalanceRequest) (*SelfBalanceResponse, error)
	//*
	//Lists all nodes on the Lightning network.
	//
	//Returns a list of all nodes visible to the underlying Lightning node,
	//including the address of the current node.
	//Nodes with private channels are not visible if not directly connected to
	//the underlying node.
	GetNodes(context.Context, *GetNodesRequest) (*NodeInfoResponse, error)
	//*
	//Searches for a Lighting node based on their Lightning address.
	//
	//Returns a list of all nodes with that address, which will be at most 1.
	//The node must be visible from the underlying node.
	SearchNodeByAddress(context.Context, *SearchNodeByAddressRequest) (*NodeInfoResponse, error)
	//*
	//Searches for a Lightning node based on their Lightning alias.
	//
	//Returns a list of all nodes with that alias visible from the underlying node.
	SearchNodeByAlias(context.Context, *SearchNodeByAliasRequest) (*NodeInfoResponse, error)
	//*
	//Connects a node as a peer.
	ConnectNode(context.Context, *ConnectNodeRequest) (*ConnectNodeResponse, error)
	mustEmbedUnimplementedNodeInfoServiceServer()
}

// UnimplementedNodeInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNodeInfoServiceServer struct {
}

func (UnimplementedNodeInfoServiceServer) GetVersion(context.Context, *VersionRequest) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedNodeInfoServiceServer) GetSelfInfo(context.Context, *SelfInfoRequest) (*SelfInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSelfInfo not implemented")
}
func (UnimplementedNodeInfoServiceServer) GetSelfBalance(context.Context, *SelfBalanceRequest) (*SelfBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSelfBalance not implemented")
}
func (UnimplementedNodeInfoServiceServer) GetNodes(context.Context, *GetNodesRequest) (*NodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}
func (UnimplementedNodeInfoServiceServer) SearchNodeByAddress(context.Context, *SearchNodeByAddressRequest) (*NodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNodeByAddress not implemented")
}
func (UnimplementedNodeInfoServiceServer) SearchNodeByAlias(context.Context, *SearchNodeByAliasRequest) (*NodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNodeByAlias not implemented")
}
func (UnimplementedNodeInfoServiceServer) ConnectNode(context.Context, *ConnectNodeRequest) (*ConnectNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectNode not implemented")
}
func (UnimplementedNodeInfoServiceServer) mustEmbedUnimplementedNodeInfoServiceServer() {}

// UnsafeNodeInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeInfoServiceServer will
// result in compilation errors.
type UnsafeNodeInfoServiceServer interface {
	mustEmbedUnimplementedNodeInfoServiceServer()
}

func RegisterNodeInfoServiceServer(s grpc.ServiceRegistrar, srv NodeInfoServiceServer) {
	s.RegisterService(&NodeInfoService_ServiceDesc, srv)
}

func _NodeInfoService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).GetVersion(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_GetSelfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).GetSelfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/GetSelfInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).GetSelfInfo(ctx, req.(*SelfInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_GetSelfBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).GetSelfBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/GetSelfBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).GetSelfBalance(ctx, req.(*SelfBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).GetNodes(ctx, req.(*GetNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_SearchNodeByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchNodeByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).SearchNodeByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/SearchNodeByAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).SearchNodeByAddress(ctx, req.(*SearchNodeByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_SearchNodeByAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchNodeByAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).SearchNodeByAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/SearchNodeByAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).SearchNodeByAlias(ctx, req.(*SearchNodeByAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoService_ConnectNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoServiceServer).ConnectNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.NodeInfoService/ConnectNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoServiceServer).ConnectNode(ctx, req.(*ConnectNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeInfoService_ServiceDesc is the grpc.ServiceDesc for NodeInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.NodeInfoService",
	HandlerType: (*NodeInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _NodeInfoService_GetVersion_Handler,
		},
		{
			MethodName: "GetSelfInfo",
			Handler:    _NodeInfoService_GetSelfInfo_Handler,
		},
		{
			MethodName: "GetSelfBalance",
			Handler:    _NodeInfoService_GetSelfBalance_Handler,
		},
		{
			MethodName: "GetNodes",
			Handler:    _NodeInfoService_GetNodes_Handler,
		},
		{
			MethodName: "SearchNodeByAddress",
			Handler:    _NodeInfoService_SearchNodeByAddress_Handler,
		},
		{
			MethodName: "SearchNodeByAlias",
			Handler:    _NodeInfoService_SearchNodeByAlias_Handler,
		},
		{
			MethodName: "ConnectNode",
			Handler:    _NodeInfoService_ConnectNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/services/rpc.proto",
}

// ChannelServiceClient is the client API for ChannelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChannelServiceClient interface {
	//*
	//Opens a channel to a node.
	//
	//Returns immediately after the funding transaction has been published,
	//but does not wait for the channel to be considered open.
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error)
}

type channelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelServiceClient(cc grpc.ClientConnInterface) ChannelServiceClient {
	return &channelServiceClient{cc}
}

func (c *channelServiceClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error) {
	out := new(OpenChannelResponse)
	err := c.cc.Invoke(ctx, "/services.ChannelService/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelServiceServer is the server API for ChannelService service.
// All implementations must embed UnimplementedChannelServiceServer
// for forward compatibility
type ChannelServiceServer interface {
	//*
	//Opens a channel to a node.
	//
	//Returns immediately after the funding transaction has been published,
	//but does not wait for the channel to be considered open.
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error)
	mustEmbedUnimplementedChannelServiceServer()
}

// UnimplementedChannelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChannelServiceServer struct {
}

func (UnimplementedChannelServiceServer) OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenChannel not implemented")
}
func (UnimplementedChannelServiceServer) mustEmbedUnimplementedChannelServiceServer() {}

// UnsafeChannelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelServiceServer will
// result in compilation errors.
type UnsafeChannelServiceServer interface {
	mustEmbedUnimplementedChannelServiceServer()
}

func RegisterChannelServiceServer(s grpc.ServiceRegistrar, srv ChannelServiceServer) {
	s.RegisterService(&ChannelService_ServiceDesc, srv)
}

func _ChannelService_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.ChannelService/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelService_ServiceDesc is the grpc.ServiceDesc for ChannelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.ChannelService",
	HandlerType: (*ChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenChannel",
			Handler:    _ChannelService_OpenChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/services/rpc.proto",
}

// ContactServiceClient is the client API for ContactService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContactServiceClient interface {
	//*
	//Lists all current contacts.
	//
	//Returns a list of all contacts currently in the database.
	GetContacts(ctx context.Context, in *GetContactsRequest, opts ...grpc.CallOption) (*GetContactsResponse, error)
	//*
	//Adds a node as a contact.
	//
	//Accepts a node and adds them as a contact in the database.
	AddContact(ctx context.Context, in *AddContactRequest, opts ...grpc.CallOption) (*AddContactResponse, error)
	//*
	//Removes a contact.
	//
	//Accepts a contact id and removes it from the database.
	RemoveContactByID(ctx context.Context, in *RemoveContactByIDRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error)
	//*
	//Removes a contact.
	//
	//Accepts a contact address and removes it from the database.
	RemoveContactByAddress(ctx context.Context, in *RemoveContactByAddressRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error)
}

type contactServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContactServiceClient(cc grpc.ClientConnInterface) ContactServiceClient {
	return &contactServiceClient{cc}
}

func (c *contactServiceClient) GetContacts(ctx context.Context, in *GetContactsRequest, opts ...grpc.CallOption) (*GetContactsResponse, error) {
	out := new(GetContactsResponse)
	err := c.cc.Invoke(ctx, "/services.ContactService/GetContacts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contactServiceClient) AddContact(ctx context.Context, in *AddContactRequest, opts ...grpc.CallOption) (*AddContactResponse, error) {
	out := new(AddContactResponse)
	err := c.cc.Invoke(ctx, "/services.ContactService/AddContact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contactServiceClient) RemoveContactByID(ctx context.Context, in *RemoveContactByIDRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error) {
	out := new(RemoveContactResponse)
	err := c.cc.Invoke(ctx, "/services.ContactService/RemoveContactByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contactServiceClient) RemoveContactByAddress(ctx context.Context, in *RemoveContactByAddressRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error) {
	out := new(RemoveContactResponse)
	err := c.cc.Invoke(ctx, "/services.ContactService/RemoveContactByAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContactServiceServer is the server API for ContactService service.
// All implementations must embed UnimplementedContactServiceServer
// for forward compatibility
type ContactServiceServer interface {
	//*
	//Lists all current contacts.
	//
	//Returns a list of all contacts currently in the database.
	GetContacts(context.Context, *GetContactsRequest) (*GetContactsResponse, error)
	//*
	//Adds a node as a contact.
	//
	//Accepts a node and adds them as a contact in the database.
	AddContact(context.Context, *AddContactRequest) (*AddContactResponse, error)
	//*
	//Removes a contact.
	//
	//Accepts a contact id and removes it from the database.
	RemoveContactByID(context.Context, *RemoveContactByIDRequest) (*RemoveContactResponse, error)
	//*
	//Removes a contact.
	//
	//Accepts a contact address and removes it from the database.
	RemoveContactByAddress(context.Context, *RemoveContactByAddressRequest) (*RemoveContactResponse, error)
	mustEmbedUnimplementedContactServiceServer()
}

// UnimplementedContactServiceServer must be embedded to have forward compatible implementations.
type UnimplementedContactServiceServer struct {
}

func (UnimplementedContactServiceServer) GetContacts(context.Context, *GetContactsRequest) (*GetContactsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContacts not implemented")
}
func (UnimplementedContactServiceServer) AddContact(context.Context, *AddContactRequest) (*AddContactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddContact not implemented")
}
func (UnimplementedContactServiceServer) RemoveContactByID(context.Context, *RemoveContactByIDRequest) (*RemoveContactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveContactByID not implemented")
}
func (UnimplementedContactServiceServer) RemoveContactByAddress(context.Context, *RemoveContactByAddressRequest) (*RemoveContactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveContactByAddress not implemented")
}
func (UnimplementedContactServiceServer) mustEmbedUnimplementedContactServiceServer() {}

// UnsafeContactServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContactServiceServer will
// result in compilation errors.
type UnsafeContactServiceServer interface {
	mustEmbedUnimplementedContactServiceServer()
}

func RegisterContactServiceServer(s grpc.ServiceRegistrar, srv ContactServiceServer) {
	s.RegisterService(&ContactService_ServiceDesc, srv)
}

func _ContactService_GetContacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContactServiceServer).GetContacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.ContactService/GetContacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContactServiceServer).GetContacts(ctx, req.(*GetContactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContactService_AddContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContactServiceServer).AddContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.ContactService/AddContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContactServiceServer).AddContact(ctx, req.(*AddContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContactService_RemoveContactByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveContactByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContactServiceServer).RemoveContactByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.ContactService/RemoveContactByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContactServiceServer).RemoveContactByID(ctx, req.(*RemoveContactByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContactService_RemoveContactByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveContactByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContactServiceServer).RemoveContactByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.ContactService/RemoveContactByAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContactServiceServer).RemoveContactByAddress(ctx, req.(*RemoveContactByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContactService_ServiceDesc is the grpc.ServiceDesc for ContactService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContactService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.ContactService",
	HandlerType: (*ContactServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContacts",
			Handler:    _ContactService_GetContacts_Handler,
		},
		{
			MethodName: "AddContact",
			Handler:    _ContactService_AddContact_Handler,
		},
		{
			MethodName: "RemoveContactByID",
			Handler:    _ContactService_RemoveContactByID_Handler,
		},
		{
			MethodName: "RemoveContactByAddress",
			Handler:    _ContactService_RemoveContactByAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/services/rpc.proto",
}

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageServiceClient interface {
	//*
	//Estimates the route and fees for the requested message.
	//
	//In case of failure (payment amount too large or small, payload too large),
	//an empty response is returned.
	EstimateMessage(ctx context.Context, in *EstimateMessageRequest, opts ...grpc.CallOption) (*EstimateMessageResponse, error)
	//*
	//Sends a message
	//
	//In case of failure (payment amount too large or small, payload too large),
	//an empty response is returned.
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	//*
	//Creates a unidirectional stream from server to client
	//over which all received messages are sent.
	//
	//The stream does not terminate until the client stops it.
	SubscribeMessages(ctx context.Context, in *SubscribeMessageRequest, opts ...grpc.CallOption) (MessageService_SubscribeMessagesClient, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) EstimateMessage(ctx context.Context, in *EstimateMessageRequest, opts ...grpc.CallOption) (*EstimateMessageResponse, error) {
	out := new(EstimateMessageResponse)
	err := c.cc.Invoke(ctx, "/services.MessageService/EstimateMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, "/services.MessageService/SendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) SubscribeMessages(ctx context.Context, in *SubscribeMessageRequest, opts ...grpc.CallOption) (MessageService_SubscribeMessagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &MessageService_ServiceDesc.Streams[0], "/services.MessageService/SubscribeMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &messageServiceSubscribeMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MessageService_SubscribeMessagesClient interface {
	Recv() (*SubscribeMessageResponse, error)
	grpc.ClientStream
}

type messageServiceSubscribeMessagesClient struct {
	grpc.ClientStream
}

func (x *messageServiceSubscribeMessagesClient) Recv() (*SubscribeMessageResponse, error) {
	m := new(SubscribeMessageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility
type MessageServiceServer interface {
	//*
	//Estimates the route and fees for the requested message.
	//
	//In case of failure (payment amount too large or small, payload too large),
	//an empty response is returned.
	EstimateMessage(context.Context, *EstimateMessageRequest) (*EstimateMessageResponse, error)
	//*
	//Sends a message
	//
	//In case of failure (payment amount too large or small, payload too large),
	//an empty response is returned.
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	//*
	//Creates a unidirectional stream from server to client
	//over which all received messages are sent.
	//
	//The stream does not terminate until the client stops it.
	SubscribeMessages(*SubscribeMessageRequest, MessageService_SubscribeMessagesServer) error
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMessageServiceServer struct {
}

func (UnimplementedMessageServiceServer) EstimateMessage(context.Context, *EstimateMessageRequest) (*EstimateMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateMessage not implemented")
}
func (UnimplementedMessageServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedMessageServiceServer) SubscribeMessages(*SubscribeMessageRequest, MessageService_SubscribeMessagesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeMessages not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_EstimateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).EstimateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.MessageService/EstimateMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).EstimateMessage(ctx, req.(*EstimateMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.MessageService/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_SubscribeMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeMessageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessageServiceServer).SubscribeMessages(m, &messageServiceSubscribeMessagesServer{stream})
}

type MessageService_SubscribeMessagesServer interface {
	Send(*SubscribeMessageResponse) error
	grpc.ServerStream
}

type messageServiceSubscribeMessagesServer struct {
	grpc.ServerStream
}

func (x *messageServiceSubscribeMessagesServer) Send(m *SubscribeMessageResponse) error {
	return x.ServerStream.SendMsg(m)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EstimateMessage",
			Handler:    _MessageService_EstimateMessage_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _MessageService_SendMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeMessages",
			Handler:       _MessageService_SubscribeMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc/services/rpc.proto",
}

// DiscussionServiceClient is the client API for DiscussionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiscussionServiceClient interface {
	//*
	//Creates a unidirectional stream from server to client
	//over which all discussions' info are sent.
	//
	//The stream terminates when all discussion info is transmitted.
	GetDiscussions(ctx context.Context, in *GetDiscussionsRequest, opts ...grpc.CallOption) (DiscussionService_GetDiscussionsClient, error)
	//*
	//Creates a unidirectional stream from server to client
	//over which previously exchanged messages belonging to
	//a specific discussion are sent.
	//
	//The stream terminates when all requested discussion messages are transmitted.
	GetDiscussionHistoryByID(ctx context.Context, in *GetDiscussionHistoryByIDRequest, opts ...grpc.CallOption) (DiscussionService_GetDiscussionHistoryByIDClient, error)
	//*
	//Calculates statistics about the requested discussion.
	GetDiscussionStatistics(ctx context.Context, in *GetDiscussionStatisticsRequest, opts ...grpc.CallOption) (*GetDiscussionStatisticsResponse, error)
	//*
	//Adds a discussion to the database.
	AddDiscussion(ctx context.Context, in *AddDiscussionRequest, opts ...grpc.CallOption) (*AddDiscussionResponse, error)
	//*
	//Updates a discussion's last read message.
	UpdateDiscussionLastRead(ctx context.Context, in *UpdateDiscussionLastReadRequest, opts ...grpc.CallOption) (*UpdateDiscussionResponse, error)
	//*
	//Removes a discussion from the database.
	RemoveDiscussion(ctx context.Context, in *RemoveDiscussionRequest, opts ...grpc.CallOption) (*RemoveDiscussionResponse, error)
	//*
	//Sends a message.
	Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)
}

type discussionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDiscussionServiceClient(cc grpc.ClientConnInterface) DiscussionServiceClient {
	return &discussionServiceClient{cc}
}

func (c *discussionServiceClient) GetDiscussions(ctx context.Context, in *GetDiscussionsRequest, opts ...grpc.CallOption) (DiscussionService_GetDiscussionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DiscussionService_ServiceDesc.Streams[0], "/services.DiscussionService/GetDiscussions", opts...)
	if err != nil {
		return nil, err
	}
	x := &discussionServiceGetDiscussionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DiscussionService_GetDiscussionsClient interface {
	Recv() (*GetDiscussionsResponse, error)
	grpc.ClientStream
}

type discussionServiceGetDiscussionsClient struct {
	grpc.ClientStream
}

func (x *discussionServiceGetDiscussionsClient) Recv() (*GetDiscussionsResponse, error) {
	m := new(GetDiscussionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *discussionServiceClient) GetDiscussionHistoryByID(ctx context.Context, in *GetDiscussionHistoryByIDRequest, opts ...grpc.CallOption) (DiscussionService_GetDiscussionHistoryByIDClient, error) {
	stream, err := c.cc.NewStream(ctx, &DiscussionService_ServiceDesc.Streams[1], "/services.DiscussionService/GetDiscussionHistoryByID", opts...)
	if err != nil {
		return nil, err
	}
	x := &discussionServiceGetDiscussionHistoryByIDClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DiscussionService_GetDiscussionHistoryByIDClient interface {
	Recv() (*GetDiscussionHistoryResponse, error)
	grpc.ClientStream
}

type discussionServiceGetDiscussionHistoryByIDClient struct {
	grpc.ClientStream
}

func (x *discussionServiceGetDiscussionHistoryByIDClient) Recv() (*GetDiscussionHistoryResponse, error) {
	m := new(GetDiscussionHistoryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *discussionServiceClient) GetDiscussionStatistics(ctx context.Context, in *GetDiscussionStatisticsRequest, opts ...grpc.CallOption) (*GetDiscussionStatisticsResponse, error) {
	out := new(GetDiscussionStatisticsResponse)
	err := c.cc.Invoke(ctx, "/services.DiscussionService/GetDiscussionStatistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionServiceClient) AddDiscussion(ctx context.Context, in *AddDiscussionRequest, opts ...grpc.CallOption) (*AddDiscussionResponse, error) {
	out := new(AddDiscussionResponse)
	err := c.cc.Invoke(ctx, "/services.DiscussionService/AddDiscussion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionServiceClient) UpdateDiscussionLastRead(ctx context.Context, in *UpdateDiscussionLastReadRequest, opts ...grpc.CallOption) (*UpdateDiscussionResponse, error) {
	out := new(UpdateDiscussionResponse)
	err := c.cc.Invoke(ctx, "/services.DiscussionService/UpdateDiscussionLastRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionServiceClient) RemoveDiscussion(ctx context.Context, in *RemoveDiscussionRequest, opts ...grpc.CallOption) (*RemoveDiscussionResponse, error) {
	out := new(RemoveDiscussionResponse)
	err := c.cc.Invoke(ctx, "/services.DiscussionService/RemoveDiscussion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionServiceClient) Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := c.cc.Invoke(ctx, "/services.DiscussionService/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiscussionServiceServer is the server API for DiscussionService service.
// All implementations must embed UnimplementedDiscussionServiceServer
// for forward compatibility
type DiscussionServiceServer interface {
	//*
	//Creates a unidirectional stream from server to client
	//over which all discussions' info are sent.
	//
	//The stream terminates when all discussion info is transmitted.
	GetDiscussions(*GetDiscussionsRequest, DiscussionService_GetDiscussionsServer) error
	//*
	//Creates a unidirectional stream from server to client
	//over which previously exchanged messages belonging to
	//a specific discussion are sent.
	//
	//The stream terminates when all requested discussion messages are transmitted.
	GetDiscussionHistoryByID(*GetDiscussionHistoryByIDRequest, DiscussionService_GetDiscussionHistoryByIDServer) error
	//*
	//Calculates statistics about the requested discussion.
	GetDiscussionStatistics(context.Context, *GetDiscussionStatisticsRequest) (*GetDiscussionStatisticsResponse, error)
	//*
	//Adds a discussion to the database.
	AddDiscussion(context.Context, *AddDiscussionRequest) (*AddDiscussionResponse, error)
	//*
	//Updates a discussion's last read message.
	UpdateDiscussionLastRead(context.Context, *UpdateDiscussionLastReadRequest) (*UpdateDiscussionResponse, error)
	//*
	//Removes a discussion from the database.
	RemoveDiscussion(context.Context, *RemoveDiscussionRequest) (*RemoveDiscussionResponse, error)
	//*
	//Sends a message.
	Send(context.Context, *SendRequest) (*SendResponse, error)
	mustEmbedUnimplementedDiscussionServiceServer()
}

// UnimplementedDiscussionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDiscussionServiceServer struct {
}

func (UnimplementedDiscussionServiceServer) GetDiscussions(*GetDiscussionsRequest, DiscussionService_GetDiscussionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDiscussions not implemented")
}
func (UnimplementedDiscussionServiceServer) GetDiscussionHistoryByID(*GetDiscussionHistoryByIDRequest, DiscussionService_GetDiscussionHistoryByIDServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDiscussionHistoryByID not implemented")
}
func (UnimplementedDiscussionServiceServer) GetDiscussionStatistics(context.Context, *GetDiscussionStatisticsRequest) (*GetDiscussionStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiscussionStatistics not implemented")
}
func (UnimplementedDiscussionServiceServer) AddDiscussion(context.Context, *AddDiscussionRequest) (*AddDiscussionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDiscussion not implemented")
}
func (UnimplementedDiscussionServiceServer) UpdateDiscussionLastRead(context.Context, *UpdateDiscussionLastReadRequest) (*UpdateDiscussionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDiscussionLastRead not implemented")
}
func (UnimplementedDiscussionServiceServer) RemoveDiscussion(context.Context, *RemoveDiscussionRequest) (*RemoveDiscussionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDiscussion not implemented")
}
func (UnimplementedDiscussionServiceServer) Send(context.Context, *SendRequest) (*SendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedDiscussionServiceServer) mustEmbedUnimplementedDiscussionServiceServer() {}

// UnsafeDiscussionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiscussionServiceServer will
// result in compilation errors.
type UnsafeDiscussionServiceServer interface {
	mustEmbedUnimplementedDiscussionServiceServer()
}

func RegisterDiscussionServiceServer(s grpc.ServiceRegistrar, srv DiscussionServiceServer) {
	s.RegisterService(&DiscussionService_ServiceDesc, srv)
}

func _DiscussionService_GetDiscussions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDiscussionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiscussionServiceServer).GetDiscussions(m, &discussionServiceGetDiscussionsServer{stream})
}

type DiscussionService_GetDiscussionsServer interface {
	Send(*GetDiscussionsResponse) error
	grpc.ServerStream
}

type discussionServiceGetDiscussionsServer struct {
	grpc.ServerStream
}

func (x *discussionServiceGetDiscussionsServer) Send(m *GetDiscussionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DiscussionService_GetDiscussionHistoryByID_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDiscussionHistoryByIDRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiscussionServiceServer).GetDiscussionHistoryByID(m, &discussionServiceGetDiscussionHistoryByIDServer{stream})
}

type DiscussionService_GetDiscussionHistoryByIDServer interface {
	Send(*GetDiscussionHistoryResponse) error
	grpc.ServerStream
}

type discussionServiceGetDiscussionHistoryByIDServer struct {
	grpc.ServerStream
}

func (x *discussionServiceGetDiscussionHistoryByIDServer) Send(m *GetDiscussionHistoryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DiscussionService_GetDiscussionStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiscussionStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussionServiceServer).GetDiscussionStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.DiscussionService/GetDiscussionStatistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussionServiceServer).GetDiscussionStatistics(ctx, req.(*GetDiscussionStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscussionService_AddDiscussion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDiscussionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussionServiceServer).AddDiscussion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.DiscussionService/AddDiscussion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussionServiceServer).AddDiscussion(ctx, req.(*AddDiscussionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscussionService_UpdateDiscussionLastRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDiscussionLastReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussionServiceServer).UpdateDiscussionLastRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.DiscussionService/UpdateDiscussionLastRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussionServiceServer).UpdateDiscussionLastRead(ctx, req.(*UpdateDiscussionLastReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscussionService_RemoveDiscussion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveDiscussionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussionServiceServer).RemoveDiscussion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.DiscussionService/RemoveDiscussion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussionServiceServer).RemoveDiscussion(ctx, req.(*RemoveDiscussionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscussionService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussionServiceServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.DiscussionService/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussionServiceServer).Send(ctx, req.(*SendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DiscussionService_ServiceDesc is the grpc.ServiceDesc for DiscussionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DiscussionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.DiscussionService",
	HandlerType: (*DiscussionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDiscussionStatistics",
			Handler:    _DiscussionService_GetDiscussionStatistics_Handler,
		},
		{
			MethodName: "AddDiscussion",
			Handler:    _DiscussionService_AddDiscussion_Handler,
		},
		{
			MethodName: "UpdateDiscussionLastRead",
			Handler:    _DiscussionService_UpdateDiscussionLastRead_Handler,
		},
		{
			MethodName: "RemoveDiscussion",
			Handler:    _DiscussionService_RemoveDiscussion_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _DiscussionService_Send_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDiscussions",
			Handler:       _DiscussionService_GetDiscussions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetDiscussionHistoryByID",
			Handler:       _DiscussionService_GetDiscussionHistoryByID_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc/services/rpc.proto",
}

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentServiceClient interface {
	//*
	//Creates a new invoice.
	CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*CreateInvoiceResponse, error)
	//*
	//Performs an invoice lookup.
	LookupInvoice(ctx context.Context, in *LookupInvoiceRequest, opts ...grpc.CallOption) (*LookupInvoiceResponse, error)
	//*
	//Performs a payment.
	Pay(ctx context.Context, in *PayRequest, opts ...grpc.CallOption) (*PayResponse, error)
	//*
	//Subscribes to invoice (final state) updates.
	SubscribeInvoices(ctx context.Context, in *SubscribeInvoicesRequest, opts ...grpc.CallOption) (PaymentService_SubscribeInvoicesClient, error)
	//*
	//Subscribes to payment (final state) updates.
	SubscribePayments(ctx context.Context, in *SubscribePaymentsRequest, opts ...grpc.CallOption) (PaymentService_SubscribePaymentsClient, error)
}

type paymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient {
	return &paymentServiceClient{cc}
}

func (c *paymentServiceClient) CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*CreateInvoiceResponse, error) {
	out := new(CreateInvoiceResponse)
	err := c.cc.Invoke(ctx, "/services.PaymentService/CreateInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) LookupInvoice(ctx context.Context, in *LookupInvoiceRequest, opts ...grpc.CallOption) (*LookupInvoiceResponse, error) {
	out := new(LookupInvoiceResponse)
	err := c.cc.Invoke(ctx, "/services.PaymentService/LookupInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) Pay(ctx context.Context, in *PayRequest, opts ...grpc.CallOption) (*PayResponse, error) {
	out := new(PayResponse)
	err := c.cc.Invoke(ctx, "/services.PaymentService/Pay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) SubscribeInvoices(ctx context.Context, in *SubscribeInvoicesRequest, opts ...grpc.CallOption) (PaymentService_SubscribeInvoicesClient, error) {
	stream, err := c.cc.NewStream(ctx, &PaymentService_ServiceDesc.Streams[0], "/services.PaymentService/SubscribeInvoices", opts...)
	if err != nil {
		return nil, err
	}
	x := &paymentServiceSubscribeInvoicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PaymentService_SubscribeInvoicesClient interface {
	Recv() (*Invoice, error)
	grpc.ClientStream
}

type paymentServiceSubscribeInvoicesClient struct {
	grpc.ClientStream
}

func (x *paymentServiceSubscribeInvoicesClient) Recv() (*Invoice, error) {
	m := new(Invoice)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *paymentServiceClient) SubscribePayments(ctx context.Context, in *SubscribePaymentsRequest, opts ...grpc.CallOption) (PaymentService_SubscribePaymentsClient, error) {
	stream, err := c.cc.NewStream(ctx, &PaymentService_ServiceDesc.Streams[1], "/services.PaymentService/SubscribePayments", opts...)
	if err != nil {
		return nil, err
	}
	x := &paymentServiceSubscribePaymentsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PaymentService_SubscribePaymentsClient interface {
	Recv() (*Payment, error)
	grpc.ClientStream
}

type paymentServiceSubscribePaymentsClient struct {
	grpc.ClientStream
}

func (x *paymentServiceSubscribePaymentsClient) Recv() (*Payment, error) {
	m := new(Payment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility
type PaymentServiceServer interface {
	//*
	//Creates a new invoice.
	CreateInvoice(context.Context, *CreateInvoiceRequest) (*CreateInvoiceResponse, error)
	//*
	//Performs an invoice lookup.
	LookupInvoice(context.Context, *LookupInvoiceRequest) (*LookupInvoiceResponse, error)
	//*
	//Performs a payment.
	Pay(context.Context, *PayRequest) (*PayResponse, error)
	//*
	//Subscribes to invoice (final state) updates.
	SubscribeInvoices(*SubscribeInvoicesRequest, PaymentService_SubscribeInvoicesServer) error
	//*
	//Subscribes to payment (final state) updates.
	SubscribePayments(*SubscribePaymentsRequest, PaymentService_SubscribePaymentsServer) error
	mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentServiceServer struct {
}

func (UnimplementedPaymentServiceServer) CreateInvoice(context.Context, *CreateInvoiceRequest) (*CreateInvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInvoice not implemented")
}
func (UnimplementedPaymentServiceServer) LookupInvoice(context.Context, *LookupInvoiceRequest) (*LookupInvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupInvoice not implemented")
}
func (UnimplementedPaymentServiceServer) Pay(context.Context, *PayRequest) (*PayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pay not implemented")
}
func (UnimplementedPaymentServiceServer) SubscribeInvoices(*SubscribeInvoicesRequest, PaymentService_SubscribeInvoicesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeInvoices not implemented")
}
func (UnimplementedPaymentServiceServer) SubscribePayments(*SubscribePaymentsRequest, PaymentService_SubscribePaymentsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribePayments not implemented")
}
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) {
	s.RegisterService(&PaymentService_ServiceDesc, srv)
}

func _PaymentService_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.PaymentService/CreateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).CreateInvoice(ctx, req.(*CreateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).LookupInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.PaymentService/LookupInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).LookupInvoice(ctx, req.(*LookupInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_Pay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).Pay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/services.PaymentService/Pay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).Pay(ctx, req.(*PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeInvoicesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PaymentServiceServer).SubscribeInvoices(m, &paymentServiceSubscribeInvoicesServer{stream})
}

type PaymentService_SubscribeInvoicesServer interface {
	Send(*Invoice) error
	grpc.ServerStream
}

type paymentServiceSubscribeInvoicesServer struct {
	grpc.ServerStream
}

func (x *paymentServiceSubscribeInvoicesServer) Send(m *Invoice) error {
	return x.ServerStream.SendMsg(m)
}

func _PaymentService_SubscribePayments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribePaymentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PaymentServiceServer).SubscribePayments(m, &paymentServiceSubscribePaymentsServer{stream})
}

type PaymentService_SubscribePaymentsServer interface {
	Send(*Payment) error
	grpc.ServerStream
}

type paymentServiceSubscribePaymentsServer struct {
	grpc.ServerStream
}

func (x *paymentServiceSubscribePaymentsServer) Send(m *Payment) error {
	return x.ServerStream.SendMsg(m)
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.PaymentService",
	HandlerType: (*PaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateInvoice",
			Handler:    _PaymentService_CreateInvoice_Handler,
		},
		{
			MethodName: "LookupInvoice",
			Handler:    _PaymentService_LookupInvoice_Handler,
		},
		{
			MethodName: "Pay",
			Handler:    _PaymentService_Pay_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeInvoices",
			Handler:       _PaymentService_SubscribeInvoices_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribePayments",
			Handler:       _PaymentService_SubscribePayments_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc/services/rpc.proto",
}
